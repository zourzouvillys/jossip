import org.gradle.plugins.ide.eclipse.model.ProjectDependency
import org.gradle.plugins.ide.eclipse.model.SourceFolder


project.apply plugin: 'eclipse'
project.apply plugin: 'com.diffplug.eclipse.apt'

project.afterEvaluate {

  if (project.tasks.findByName('cleanEclipseFactorypath')) {
	  project.rootProject.tasks['configureBuildship'].dependsOn(
	    project.tasks['cleanEclipseFactorypath'],
	    project.tasks['cleanEclipseClasspath'],
	    project.tasks['cleanEclipseJdtApt'],
	    project.tasks['cleanEclipseJdt'],
	    project.tasks['cleanEclipseProject'],
	    project.tasks['eclipseClasspath'],
	    project.tasks['eclipseFactorypath'],
	    project.tasks['eclipseJdt'],
	    project.tasks['eclipseJdtApt'],
	    project.tasks['eclipseProject']
	  )
  }  
  else if (project.tasks.findByName('eclipseFactorypath')) {
	  project.rootProject.tasks['configureBuildship'].dependsOn(
	    project.tasks['eclipseClasspath'],
	    project.tasks['eclipseFactorypath'],
	    project.tasks['eclipseJdt'],
	    project.tasks['eclipseJdtApt'],
	    project.tasks['eclipseProject']
	  )
  }  

  eclipse {
    project {
      name = createProjectDisplayName()
    }
  }
  
  

  eclipse.classpath.file.whenMerged { classpath ->
    classpath.entries.find { it.path == '.apt_generated' }.each {
      classpath.entries.remove(it)
    }
    // ignore compilation warnings in the apt-generated code		
    def lib = new org.gradle.plugins.ide.eclipse.model.SourceFolder('.apt_generated', null)
    lib.entryAttributes['ignore_optional_problems'] = true
    lib.entryAttributes['optional'] = true
    classpath.entries.add(lib)  
  }

  eclipse.classpath.file.whenMerged { classpath ->

    classpath.entries.findAll { it instanceof ProjectDependency }.each {
    
      // delete from original position
	  classpath.entries.remove(it)

	// append to end of classpath	
	  def dep = new ProjectDependency(it.path) {
	    @Override
        public void appendNode(Node node) {
          Map<String, Object> attrs = new HashMap<>();
          attrs.put("combineaccessrules", "false")
          addClasspathEntry(node, attrs);
        }
	  }
	
  	  dep.entryAttributes['module'] = true
	
	  //dep.entryAttributes['gradle_scope'] = 'main'
	  //dep.entryAttributes['gradle_used_by_scope'] = 'main,test'
	  //dep.entryAttributes['without_test_code'] = 'false' 
	
	  classpath.entries.add(dep)
	
    }
  
  }




  
  
  
  
}


def createProjectDisplayName() {
  if (project == project.rootProject) {
    return project.name  
  }
  return "${project.rootProject.name}${project.path}"
}


  

